## DOES NOT WORK FOR PURE R32 instructionset. Need to add more instructions
###
# This program runs matrix calculation of
  # C = C + A * B, where it is supposed that
  # C = [
  #  -6, 5, -8, 5, 9,
  #  1, 0, -6, 4, -2,
  #  -6, -5, -6, 6, -3,
  # ]
  #
  # A = [
  #  6, 5, 1, 8,
  #  2, 5, 9, -6,
  #  -9, 0, 0, 2
  # ]
  #
  # B = [
  #  2, -8, 1, 3, 7,
  #  5, -5, -5, 2, -7,
  #  -1, -3, 7, -2, 5,
  #  4, -7, -4, 6, 5
  # ]
  # Memory and register are set to work for these values accordingly as well.
  ####################
  ####################
  
  MAIN:
      # MAIN stack
      addi  x2,  x2, -64
      sd    x8,   0(x2)
      addi  x8,  x2,  64
      sd    x1,  -8(x8)
      sd   x10, -16(x8)
      sd   x11, -24(x8)
      sd   x12, -32(x8)
      sd   x13, -40(x8)
      sd   x14, -48(x8)
      sd   x15, -56(x8)
  
      # Address of matrix A = 1600 x11
      # Address of matrix B = 2400 x12
      # Address of matrix C = 3200 x10
      addi x10,  x0, 1600
      slli x10, x10,    1 # x10 = 3200
      addi x11,  x0, 1600 # x11 = 1600
      addi x12,  x0, 1200
      slli x12, x12,    1 # x12 = 2400
  
      # Matrix A = M (rows) * N (cols)
      # Matrix B = N (rows) * K (cols)
      # Matrix C = M (rows) * K (cols)
      # M = 3, N = 4, K = 5
      addi x13,  x0,   3
      addi x14,  x0,   4
      addi x15,  x0,   5
  
      # Call subroutine MMA(C, A, B, M, N, K)
      # C += A * B
      jal   x1, MMA
  
      # Clear MAIN stack
      ld    x1,  -8(x8)
      ld   x10, -16(x8)
      ld   x11, -24(x8)
      ld   x12, -32(x8)
      ld   x13, -40(x8)
      ld   x14, -48(x8)
      ld   x15, -56(x8)
      ld    x8,   0(x2)
      addi  x2,  x2,  64
  
      # End of the program (x1 == 0)
      jalr  x0, 0(x1)
  
  
  ################
  # Equivalent python code
  ################
  
  # i = 0
  # j = 0
  # k = 0
  # c_row = 0;
  # MATRIX_A_WIDTH = 4 # x14
  # MATRIX_A_HEIGHT = 3 # x13
  # MATRIX_B_WIDTH = 5 #x15 
  # 
  # while True:
  #   if k == MATRIX_B_WIDTH * MATRIX_A_HEIGHT:
  #     break
  #   C[k] = C[k] + A[i] * B[j]
  #   # i reaches the rightmost index of the row of A matrix
  #   if i != 0 and (i + 1) % (MATRIX_A_WIDTH) == 0:
  #     k += 1
  #     # handle next row of C
  #     if k % MATRIX_B_WIDTH == 0:
  #       # move i to the next row of matrix A
  #       c_row += 1
  #       i = ((c_row) * MATRIX_A_WIDTH)
  #       # locate j at the first column for a fresh multiplication
  #       j = 0
  #     # handle next element in the same row in C
  #     else:
  #       i = c_row * MATRIX_A_WIDTH
  #       j = k % MATRIX_B_WIDTH
  #   # i hasn't reached the rightmost index of the row of A matrix
  #   else:
  #     i += 1
  #     j += MATRIX_B_WIDTH
  
  # addi x13,  x0,   3
  # addi x14,  x0,   4
  # addi x15,  x0,   5
  # 1600 x11 A
  # 2400 x12 B
  # 3200 x10 C
  # X18â€“x27: saved registers
  # x5-x7, x28-x31: temp registers
  # Write MMA function that calculates C += A * B.
  MMA:
      # stack pointer for 3 items
      addi, x2,  x2, -24
      sd x18, 16(x2)
      sd x19, 8(x2)
      sd x20, 0(x2)
      # i: unsigned bit offset from 1600 (x11)
      # i = 0
      addi x5, x0, 0
      # j: unsigned bit offset from 2400 (x12) 
      # j = 0
      addi x6, x0, 0 
      # k: unsigned bit offset from 3200 (x10) 
      # k = 0
      addi x7, x0, 0
      # c_row: integer for marking nth row in matrix C (unit: row, not bytes)
      # c_row = 0
      addi x31, x0, 0
  
      beq x0, x0, MMA_MAIN    
  
  MMA_MAIN:
      # if k == MATRIX_B_WIDTH * MATRIX_A_HEIGHT:
      #    break
      mul x18, x13, x15
      srli x19, x7, 3
      beq x18, x19, MMA_EXIT
  
      # C[k] = C[k] + A[i] * B[j]
  
      # 1. Get A[i] (x18 = A[i])
      add x18, x5, x11 
      ld x18, 0(x18)
  
      # 2. Get B[j] (x19 = B[j])
      add x19, x6, x12
      ld x19, 0(x19)
  
      # 3. temp = A[i] * B[j]
      mul x18, x18, x19
  
      # 4. Get C[k]
      add x19, x10, x7
      ld x19, 0(x19)
  
      # 5. C[k] = C[k] + temp
      add x19, x19, x18
  
      add x18, x10, x7
      sd x19, 0(x18)
  
      # if i != 0 and (i + 1) % (MATRIX_A_WIDTH) == 0:
      beq x5, x0, ELSE
  
      # 1. Get (i + 1)
      addi x19, x5, 8
      # 2. Get MATRIX_A_WIDTH
      addi x20, x14, 0
      slli x20, x20, 3
      # 3. x18 = (i + 1) % (MATRIX_A_WIDTH)
      remu x18, x19, x20
      # 4. if x18 != x0: go to ELSE
      bne x18, x0, ELSE
          
      # k += 1
      addi x7, x7, 8
  
      # if k % MATRIX_B_WIDTH == 0:
      addi x18, x15, 0
      slli x18, x18, 3
      remu x18, x7, x18
      bne x0, x18, NESTED_ELSE
  
      # c_row += 1
      # i = ((c_row) * MATRIX_A_WIDTH)
      # j = 0
      # 1. c_row += 1
      addi x31, x31, 1
  
      # 2. i = ((c_row) * MATRIX_A_WIDTH)
      add x18, x0, x14
      slli x18, x18, 3
      mul x5, x31, x18
  
      # 3. j = 0
      addi x6, x0, 0
  
      # since this is a while loop, go back
      # to the start of the function
      beq x0, x0, MMA_MAIN
  
  ELSE:
      # else:
      #    i += 1
      #    j += MATRIX_B_WIDTH
      addi x5, x5, 8
      slli x18, x15, 3
      add x6, x6, x18
  
      # since this is a while loop, go back
      # to the start of the function
      beq x0, x0, MMA_MAIN
  
  NESTED_ELSE:
      # i = c_row * MATRIX_A_WIDTH
      add x19, x0, x14
      slli x19, x19, 3
      mul x5, x31, x19
  
      # j = k % MATRIX_B_WIDTH
      add x20, x0, x15
      slli x20, x20, 3
      remu x6, x7, x20
  
      # since this is a while loop, go back
      # to the start of the function
      beq x0, x0, MMA_MAIN
  
  MMA_EXIT:
      ld x20, 0(x2)
      ld x19, 8(x2)
      ld x18, 16(x2)
      addi, x2,  x2, 24
  
      jalr  x0, 0(x1)